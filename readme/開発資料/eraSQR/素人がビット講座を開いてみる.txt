@プログラム初心者が教えるビット講座

0. この文章を読むにあたっての諸注意
この文章は既存のビット講座を読んだけども意味がわからない、という人を対象にかかれたものです。
どのような状況で使えばいいのか、どうやって使えばいいのか、ということを中心に解説しており、ビット演算の理屈、理論についてはあまり触れておりません。

また作者はプログラムの知識はERAに出会うまで皆無であったので、この文章には多くの誤解と不適切な表現が含まれているはずです。ですので、ビット演算について、まずは既存のビット講座を参考にしてください。

1. なぜビット演算を使うのか
	あるフラグに複数の情報を載せる場合、どうすればよいだろうか。
たとえばチンコに精液、愛液、唾液、アナルの汚れ、などが付着している様子を示したい場合、
FLAG:1 = 1ならば精液が付着、FLAG:1 = 2ならば愛液が付着というような処理ではだめである。
なぜなら精液と愛液が同時に付着している場合も考えられるからである。
同時に付着している場合、
FLAG:1 = 3ならば精液と愛液が同時に付着している、などと定義することは可能であるが、
唾液、アナルの汚れ、等々要素が増えるにしたがって加速度的に処理が煩雑になり、効率的な作業は期待できなくなる。

たとえば
FLAG:1 = 1 ならば精液が付着、0ならば精液は付着していない
FLAG:2 = 1 ならば愛液が･･･
などという記述も可能であろうが、ビットを使うことでこの冗長な処理をまとめることができるのである。
------------------------------------------------------------------------------------------------
2. ビット演算の使い方
	多くのバリアントでは汚れはSTAINという変数で管理している。
SQRではMASTERのチンコの汚れはSTAIN:MASTER:2という変数に格納されている。
<例>
;部位
STAIN:0 = 口
STAIN:1 = 手
STAIN:2 = ペニス　　　備考：調教開始時にペニスの汚れが付着(STAIN:X:2 = 2)
STAIN:3 = ヴァギナ　　備考：調教開始時に愛液の汚れが付着　(STAIN:X:3 = 1)
STAIN:4 = アナル　　　備考：調教開始時にアナルの汚れが付着(STAIN:X:4 = 8)
STAIN:5 = 胸
STAIN:6 = 足

;汚れの内容
※ビット演算処理
1 = 愛液
2 = ペニス
4 = 精液
8 = アナル
16= 母乳
32= 血
64= 粘液

もし、MASTERのチンコにアナルの汚れが付着するような行動をすると、|という演算子を用いてその情報をSTAIN:MASTER:2に書き込むことができる。
	STAIN:MASTER:2 |= 8
血がついたなら
	STAIN:MASTER:2 |= 32
となる。
なぜ8や64のような2のN乗の数字を用いるかは後で解説する。


|=という演算子は誤解を恐れずに言うと、足し算である。
	STAIN:MASTER:2 |= 8
という式は
	STAIN:MASTER:2 += 8
考えてもらってもいい。

アナルに挿入したら裂けて血が出た場合は、
	STAIN:MASTER:2 |= 8
	STAIN:MASTER:2 |= 32
と、続けて書き込むことで、アナルの汚れと血が付着している情報をチンコに格納することができる。

さて、チンコが汚れているとき調教対象が特定の行動をする、というシチュエーションを想定してほしい。
このとき
	IF "チンコが汚れています"
		PRINTL チンコが汚れているのでくわえたくないようだ
	ENDIF
というような構文が考えられる。

IF以下にチンコが汚れているかどうかを判別する式を入れる必要があり、このときに使用する演算子が&である。
	IF STAIN:MASTER:2 & 8 > 0
		PRINTL チンコが汚れているのでくわえたくないようだ
	ENDIF

もし以前に
	STAIN:MASTER:2 |= 8
と、チンコにアナルの汚れを付着させたなら、
	STAIN:MASTER:2 & 8
という式の答えは正の数字となる。すなわち
	STAIN:MASTER:2 & 8 > 0
である。
またSTAIN:MASTER:2が初期化されて以後、
	STAIN:MASTER:2 |= 8
という式が一度も使われていなければ
	STAIN:MASTER:2 & 8 = 0
となる。

|や&が何をしているのかはここでは触れず後で解説することにする。

------------------------------------------------------------------------------------------------
3. 2進数
	2進数とは0と1のみで表された数字のことである。普段われわれが使う数字は10進数であり、2進数と10進数は以下の関係にある。
10進数	2進数
0		0
1		1
2		10
3		11
4		100
5		101
6		110
7		111
8		1000
9		1001
10		1010
11		1011
12		1100
13		1101
14		1110
15		1111
16		10000
詳しい説明は数学の教科書に譲ることにして、以下に構文で用いる上で便利な2進数の持つ性質を見ていくことにしよう。

3-1. 10進数と2進数
	上の10進数と2進数との対比を見てもらいたい。
2進数で桁が上がる数字（1, 10, 100, 1000, 10000）を10進数で表すとそれぞれ、1, 2, 4, 8, 16となる。
すなわち10進数で表示したとき2の0乗、１乗、2乗、･･･となるときに2進数では桁が上がる。

3-2. 2進数の足し算
	たとえば2進数における	10 + 110という足し算を考えてみる。10進数で表記すると2 + 6である。
もちろん10 + 110 = 120という答えにはならない。2進数では2という数字は存在せず、繰り上がって10となる。
	  10
	+110
	――
筆算すると答えの1桁目は0、2桁目は繰り上がって10、3桁目も繰り上がって10なので答えは1000となる。
10進数で表記すると 2 + 6はもちろん8なので、2進数の足し算と10進数の足し算の答えは一致する。

さて、ビット演算では主に2のn乗の数字の足し算(厳密には違う)が行われる（と思う）。
<例-SQNのフラグに用いられるビット>
CFLAG:467	妊娠イベントフラグ
& 64	妊娠予定の潜伏期間
& 128	妊娠期間
& 256	出産間近&お産
& 512	子育て
& 1024	危険日

たとえば4 + 8（2進数表記では100 + 1000）を考えてみよう。
	  100
	+1000
	―――
	 1100
ここで重要なのは2のN乗同士の足し算では繰り上がりが生じないことにある。
また1 OR 0で考えると、4は3桁目に1、8は4桁目に1があるが、答えの1100に注目すると、その情報が保存されている。
------------------------------------------------------------------------------------------------
4. ビット演算
	SQRではマップ情報の処理にビット演算を使用している。
FLAG:1800 ～FLAG:1899に10*10のフロアのそれぞれひとつのパネルと対応している。
たとえばFLAG:1800はフロアの一番左上、FLAG:1809にはフロアの一番右上のパネルの情報を格納している。
パネルには、障害物がそのパネルにあるかどうか、MASTERがそのパネルにいるかいないか、敵がいるかどうか、アイテムがあるかどうか、などの情報が格納されている。これらの情報をひとつのフラグに全部詰め込むためにビット演算を使用しているわけである。

マップが生成されるときまず最初にフラグの初期化、FLAG:1800 = 0, FLAG:1801 = 0,･･･という処理が行われている。
次に障害物が設置される。適当なフラグを選んで、たとえばマップの一番左上が選ばれたなら
FLAG:1800 |= 1
という処理が行われている。|=とは足し算みたいなもので、ここではFLAG:1800 + 1(2の0乗) = 0 + 1と同じ処理が行われている（もちろん厳密には違う）。

次に障害物が置かれていない場所（いしのなかにいる）にMASTER、敵、アイテム、階段などが設置される。
たとえばマップの左上にMASTERをおきたいのなら
FLAG:1800 |= 4
という処理を施す。

前述したように、ビット演算では2のN乗の足し算が行われる。
同じ地点(フロアの左上)にアイテムをおきたいのなら
FLAG:1800 |= 16である。

このとき
FLAG:1800 |= 4 は FLAG:1800 = FLAG:1800 + 4 = 0 + 4 = 4
FLAG:1800 |= 16では FLAG:1800 = FLAG:1800 + 16 = 4 + 16 = 20という処理が行われている(と思う）。
二進数で表すなら
4 + 16 = 100 + 10000 = 10100　である。

4-1. 演算子&
	ここで2のN乗同士の足し算なら、繰上りが生じない、桁の情報が保存される、ということを思い出していただきたい。
桁の情報が保存されているかぎり、10100の3桁目が1か0かを判別することでそのパネルにMASTERがいるかいないか、ということを判別できるのである。
ある数字のある桁が0か1かを判別する時に用いる演算子が&である。

たとえば20を2進数で表示したとき(10100)の3桁目が1か0かを知りたいとき、
	20 & 4
という式を用いる。20の3桁目は1であり
	20 & 4 = 4 = 100 (2進数表記)
となる。
	20 & 8
という式は20の4桁目が1か0かを判別しており、
	20 & 8 = 0
となる。
以上のように、&を用いた式は、ある桁が1ならば答えは1以上の値が答えとなり、0ならば答えは0となる。

<例>
IF FLAG:M & 4 > 0 && FLAG:M & 16 > 0
	PRINTL 宝箱を見つけた
	PRINTW 開錠を試みますか？

この例はあるパネルに対応するFLAGの数値の3桁目に1、5桁目に1がある場合、下の処理を行う命令である。
もちろんFLAG:M = 20ならば
	FLAG:M & 4 = 4 = 100 > 0
	FLAG:M & 16 = 16 = 10000 > 0
であるのでこの命令は実行される。
また
	FLAG:M = 54(2進数では110110)
でも同様である。

4-2. 演算子|
	さっきから|=は足し算だといい続けてきたが、あれは嘘だ。忘れてくれ。
FLAG:1800 = 6 = 110(2進数表記)のとき、
FLAG:1800 |= 4 = 6 + 4 = 10 = 1010(2進数表記)とはならない。
	4  =  100
	10 = 1010
なので、そのままの足し算では肝心な3桁目の情報が保存されないことがお分かりだろう。
実際には
	  110
	| 100
	―――
	  110
	 FLAG:1800 |= 6
である(多分)。

詳しくはほかの解説に譲るとして、|を使った演算では桁の情報が保存されるということが理解できればいい。
FLAG:1800 |= 4という演算を行ったのなら、その前後で|=を使ってどんな計算をしようと
FLAG:1800 & 4 = 4となるのである。

4-3.ビットを消したいとき
	MASTER、敵の移動したときなど、元の位置のFLAGをそのままにしておけば、MASTER、敵の分裂といった現象が生じてしまう。
そのため、FLAGの消去を行う必要があるが、そのためには引き算を用いている(ほかの方法があるかもしれない)。
<例>
			PRINTL 宝箱を開錠した
			PRINTFORMW 開錠経験 +{A}
			CALL DUNGEON_MOVE
			FLAG:M -= 16
このときFLAG:Mから10000を引くことにより、FLAG:Mの5桁目の数字を0にしているわけである。
ここで注意しなければいけないのは、もともとFLAG:Mの5桁目が0の場合、繰り下がりが生じてしまい、ほかのビットに影響を与えてしまいかねない。
この場合、5桁目が1であることが明白なので特別な処理をしていないが、
SIF FLAG:M & 16 > 0
というような処理が必要となることもあるだろう。




