;-------------------------------------------------
;雑多な関数置き場(未整理)
;-------------------------------------------------
;過去に誰かさんがこっそり作っていた怪しいパッチ(?)や未完成の口上(?)などから、
;比較的使えそうだけど分類がよくわからない関数を抜き出して集めたファイル
;完全に合法なのでごあんしんください
;割とシンプルな関数…かな？
;そのうち整理されると思いますので配置や処理など変わるかもしれません@revkoishi(14/05/19)
;-------------------------------------------------
;関数の概要
;・INPUT_RANGE(|D)…指定範囲内かどうかのチェックを行う数値入力関数
;・TINPUT_RANGE(|D)…時間制限つきのINPUT_RANGE
;・NOBYNAME…NAMEまたはCALLNAMEからNOを取得する式中関数
;・SIGN(S|V)…引数0の数値の符号に基づき、引数1～3の中から1つを返す式中関数
;・SRL…論理右シフト演算した結果を返す式中関数
;-------------------------------------------------

;-------------------------------------------------
;関数名:INPUT_RANGE(|D)
;概　要:指定範囲数値入力関数
;引　数:ARG:0…[省略可] 入力を許可する下限値。省略した場合は0
;　　　 ARG:1…[省略可] 入力を許可する上限値。省略した場合は1
;　　　 ARG:2…[省略可] 引数の大小に応じて下限値・上限値を設定するかどうか(真偽値)。省略した場合は偽(0、しない)
;　　　　　　　　　　　 真(0以外)にした場合は、ARG:0とARG:1を比較して小さいほうを下限・大きいほうを上限とします
;戻り値:ユーザの入力した数値(ARG:0～ARG:1の間)
;基本的にDO-LOOP内でINPUTした結果をINRANGEでチェックしているだけです
;別にINPUTINT使っても良いのですが折角なので
;特に捻りのないメニューとかは戻るを-1にしておけばこれで十分だったり
;Dオプションで入力時などの文字色をデフォルト色で表示できます。主に口上向け
;-------------------------------------------------
@INPUT_RANGE(ARG:0 = 0, ARG:1 = 1, ARG:2 = 0)
#LOCALSIZE 2
SIF ARG:2 && ARG:0 > ARG:1
	SWAP ARG:0, ARG:1
SIF ARG:0 > ARG:1
	THROW @INPUT_RANGEで例外が発生。無効な許容範囲です（{ARG:0}～{ARG:1}）　※ARG:2（{ARG:2}）を真にすることでも回避できます
LOCAL:1 = CURRENTREDRAW()
REDRAW 0
DO
	INPUT
	LOCAL:0 = !INRANGE(RESULT, ARG:0, ARG:1)	;入力チェック:範囲外
	IF LOCAL:0
		CLEARLINE 1
		REUSELASTLINE 入力値が範囲外です
	ENDIF
LOOP LOCAL:0
REDRAW LOCAL:1
RETURN RESULT

@INPUT_RANGED(ARG:0 = 0, ARG:1 = 1)
#LOCALSIZE 1
LOCAL:0 = GETCOLOR()
RESETCOLOR
CALL INPUT_RANGE(ARG:0, ARG:1)
SETCOLOR LOCAL:0
RETURN RESULT


;-------------------------------------------------
;関数名:TINPUT_RANGE(|D)
;概　要:時間制限つき指定範囲数値入力関数
;引　数:ARG:0…[省略可] 入力を許可する下限値。省略した場合は0
;　　　 ARG:1…[省略可] 入力を許可する上限値。省略した場合は1
;　　　 ARG:2…[省略可] 引数の大小に応じて下限値・上限値を設定するかどうか(真偽値)。省略した場合は偽(0、しない)
;　　　　　　　　　　　 真(0以外)にした場合は、ARG:0とARG:1を比較して小さいほうを下限・大きいほうを上限とします
;　　　 ARG:3…[省略可] 制限時間(ミリ秒)。100ミリ秒単位より細かい値を設定しても正確な動作はできませんので注意。省略した場合は10,000ミリ秒
;　　　 ARG:4…[省略可] 時間切れ時の戻り値。省略した場合は__INT_MIN__
;　　　 ARG:5…[省略可] 残り時間表示(真偽値)。真(0以外)の場合は残り時間表示を行います。省略した場合は真(表示する)
;戻り値:ユーザの入力した数値(ARG:0～ARG:1の間)、もしくは時間切れ時の戻り値
;INPUT_RANGEの時間制限付き版。TINPUTINTとは引数順や省略時の挙動などが違ったり
;でも何に使うのかはよくわからない（ぇ
;Dオプションで入力時などの文字色をデフォルト色で表示できます。主に口上向け
;-------------------------------------------------
@TINPUT_RANGE(ARG:0 = 0, ARG:1 = 1, ARG:2 = 0, ARG:3 = 10000, ARG:4 = __INT_MIN__, ARG:5 = 1)
#LOCALSIZE 5
SIF ARG:2 && ARG:0 > ARG:1
	SWAP ARG:0, ARG:1
SIF ARG:0 > ARG:1
	THROW @TINPUT_RANGEで例外が発生。無効な許容範囲です（{ARG:0}～{ARG:1}）　※ARG:2（{ARG:2}）を真にすることでも回避できます
LOCAL:2 = LINECOUNT
LOCAL:3 = CURRENTREDRAW()	;REDRAW 0 で入ってくると残り時間表示が動かないためこのガードは重要
LOCAL:4 = 0					;再入力フラグ
REDRAW ARG:5 != 0
DO
	LOCAL:1 = GETMILLISECOND()
	TINPUT ARG:3, ARG:4, ARG:5
	ARG:3 -= GETMILLISECOND() - LOCAL:1
	IF ARG:3 > 0
		LOCAL:0 = !INRANGE(RESULT, ARG:0, ARG:1)
		IF LOCAL:0
			CLEARLINE LINECOUNT - LOCAL:2
			PRINTL 入力値が範囲外です
		ENDIF
		LOCAL:4 = 1
	ELSE
		LOCAL:0 = 0
		;※暫定処理。ISTIMEOUT変数が修正された後、正式対応するかも(しなくてもいいかも)
		;入力後時間切れかつ入力値範囲外の場合は時間切れ捏造
		IF HTML_TOPLAINTEXT(HTML_GETPRINTEDSTR(2)) != "時間切れ" && !INRANGE(RESULT, ARG:0, ARG:1)
			RESULT = ARG:4
			CLEARLINE LINECOUNT - LOCAL:2
			PRINTFORML \@ LOCAL:4 ? 入力値が範囲外です\n # \@時間切れ\n{RESULT}
		ENDIF
		;入力後時間切れかつ入力値範囲内の場合は時間内に正しく入力出来ているのでスルー
		;入力中時間切れの場合はTINPUTで時間切れ処理行われているのでスルー
	ENDIF
LOOP LOCAL:0
REDRAW LOCAL:3
RETURN RESULT

@TINPUT_RANGED(ARG:0 = 0, ARG:1 = 1, ARG:2 = 0, ARG:3 = 10000, ARG:4 = __INT_MIN__, ARG:5 = 1)
#LOCALSIZE 1
LOCAL:0 = GETCOLOR()
RESETCOLOR
CALL TINPUT_RANGE(ARG:0, ARG:1, ARG:2, ARG:3, ARG:4, ARG:5)
SETCOLOR LOCAL:0
RETURN RESULT


;-------------------------------------------------
;関数名:NOBYNAME
;概　要:キャラ名→キャラ番号変換関数
;引　数:ARGS:0…キャラの名前(NAME)または呼び名(CALLNAME)
;戻り値:指定したキャラのキャラ番号(NO)
;備　考:式中関数
;いちいち全キャラのNOとか覚えてないでしょうし、都度調べるのも面倒でしょうし…
;実はNO相当の数値文字列でも通るけど特殊用途なのでお察しください
;機能的に除外しようか迷ったけど、他の関数内で使う分には便利かなと思って…
;文字列教？ さて、なんのことでしょうか(すっとぼけ)
;-------------------------------------------------
@NOBYNAME(ARGS:0)
#FUNCTION
#LOCALSIZE 1
LOCAL:0 = ISNUMERIC(ARGS:0) ? TOINT(ARGS:0) # GETNUM(RELATION, ARGS:0)
SIF !EXISTCSV(LOCAL:0)
	THROW @NOBYNAMEで例外が発生しました。存在しないキャラ名もしくはキャラ番号です（%ARGS:0%）
RETURNF LOCAL:0


;-------------------------------------------------
;関数名:SIGNS
;概　要:数値の符号で3分岐させる関数(文字列版)
;引　数:ARG:0 …分岐の条件となる数値
;　　　 ARGS:0…ARG:0がマイナスだった時の戻り値
;　　　 ARGS:1…ARG:0が±0だった時の戻り値
;　　　 ARGS:2…ARG:0がプラスだった時の戻り値
;戻り値:ARG:0に基づき、ARGS:0~2のいずれか
;備　考:式中関数
;ときどき三項演算子だと手が足りなくて、こういうのが欲しくなるような…気がする
;当然ですが短絡評価しませんので、キャラクタ変数などを渡したい場合にはご注意を
;見た目条件分岐してないのにちゃんと分岐するのがウリ(?)
;<=>や－±＋を渡したりすると場所によってはシンプルに書けるかも
;とはいえ同じパターンを頻繁に用いるなら別途関数化した方が早いとは思うけど
;-------------------------------------------------
@SIGNS(ARG:0, ARGS:0, ARGS:1, ARGS:2)
#FUNCTIONS
RETURNF ARGS:(SIGN(ARG:0) + 1)


;-------------------------------------------------
;関数名:SIGNV
;概　要:数値の符号で3分岐させる関数(数値版)
;引　数:ARG:0…分岐の条件となる数値
;　　　 ARG:1…ARG:0がマイナスだった時の戻り値
;　　　 ARG:2…ARG:0が±0だった時の戻り値
;　　　 ARG:3…ARG:0がプラスだった時の戻り値
;戻り値:ARG:0に基づき、ARG:1~3のいずれか
;備　考:式中関数
;SIGNSとやってることは一緒です。SやVの意味はPRINTSやPRINTVと一緒
;関数名はSIGN_STRやSIGN_INTにした方が解り易いのではとも思ったけれど、
;この手の関数は名前が短い方が取り回しやすい気がしたので…
;-------------------------------------------------
@SIGNV(ARG:0, ARG:1, ARG:2, ARG:3)
#FUNCTION
RETURNF ARG:(SIGN(ARG:0) + 2)


;-------------------------------------------------
;関数名:SRL
;概　要:論理右シフト関数
;引　数:ARG:0…シフト対象のビット列
;　　　:ARG:1…シフトカウント
;戻り値:論理右シフト演算結果
;備　考:式中関数
;論理右シフト演算っぽい計算を行う(某言語の>>>演算子みたいな雰囲気)
;符号ビットの状態に関わらず、空いたビットに0が入る
;関数名はShiftRightLogicalより。今となってはあまり使わない感
;-------------------------------------------------
@SRL(ARG:0, ARG:1)
#FUNCTION
ARG:1 &= 0x3F	;念のため下位6bitを取り出してシフトカウントとする(0～63)。Emueraの動き(C#の動き)に合わせたつもり
;シフトカウントが0でなければ、論理右シフトもどきをして返す。0ならば、ARG:0をそのまま返す
RETURNF ARG:1 ? (ARG:0 >> ARG:1) & (0x7FFFFFFFFFFFFFFF >> ARG:1 - 1) # ARG:0
